<?php
/**
 * @file
 * Lingotek Community Translation Hooks, Added Fields on Node Creation
 */

include_once("lingotek.session.inc");
include_once('lingotek.reference.inc');
include_once("lingotek.util.inc");
include_once("lingotek.api.inc");
include_once("lingotek.sync.inc");
include_once("lingotek.mt.inc");

/*
 * menu hook
 */
function lingotek_menu() {
  $items = array();

  $items['admin/settings/lingotek'] = array
  (
    'title' => 'Lingotek',
    'description' => 'Collaborative Translation Settings',
    'file' => 'lingotek.admin.inc',
    'page callback' => 'lingotek_settings_page',
    'access arguments' => array('lingotek_administer'),
  );

  $items['node/%node/lingotek_pm'] = array
  (
    'title' => 'Lingotek',
    'access arguments' => array('lingotek_content_tab'),
    'file' => 'lingotek.page.inc',
    'page arguments' => array(1),
    'page callback' => 'lingotek_summary',
    'type' => MENU_LOCAL_TASK,
    'weight' => 3,
  );

  $items['lingotek/update'] = array
  (
    'access arguments' => array('lingotek_sync_from_lingotek'),
    'file' => 'lingotek.page.inc',
    'page callback' => 'lingotek_update',
    'type' => MENU_CALLBACK,
  );

  $items['lingotek/mt_all'] = array
  (
    'access arguments' => array('lingotek_administer'),
    'file' => 'lingotek.page.inc',
    'page callback' => 'lingotek_mt_all',
    'type' => MENU_CALLBACK,
  );

  $items['lingotek/segment'] = array
  (
    'access arguments' => array('lingotek_machine_translation'),
    'file' => 'lingotek.mt.inc',
    'page callback' => 'lingotek_mt_save_segment',
    'type' => MENU_CALLBACK,
  );

  $items['lingotek/mt'] = array
  (
    'access arguments' => array('lingotek_machine_translation'),
    'file' => 'lingotek.page.inc',
    'page callback' => 'lingotek_mt_ajax',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/*
 * permissions hook
 */
function lingotek_perm() {
  return array('lingotek_content_tab', 'lingotek_administer', 'lingotek_translate', 'lingotek_review_translations', 'lingotek_sync_from_lingotek', 'lingotek_machine_translation', 'lingotek_create_content_options');
}

/*
 * flush the queue for machine translation on every page load
 */
function lingotek_init() {
  $menu = menu_get_active_trail();
  //Skip AJAX calls
  if ("" != $menu[1]['title']) {
    lingotek_dequeue();
  }
}

/*
 * form_alter hook
 */
function lingotek_form_alter(&$form, $form_state, $form_id) {
  switch ($form_id) {
    default:
      if (isset($form['#id']) && strpos($form['#id'], 'node-form') !== FALSE && isset($form['#node']->type)) {
        $nid = $form['#parameters'][2]->nid;
        //Only give options if the node is new
        if (!isset($nid)) {
          $form['lingotek'] = array
          (
            '#title' => t('Lingotek Settings'),
            '#type' => 'fieldset', '#collapsible' => TRUE,
            '#collapsed' => TRUE,
            '#description' => t("These settings can only be set once, when creating the page."),
            '#access' => user_access('lingotek_create_content_options'),
          );
          $form['lingotek']['phaseTemplate'] = array
          (
            '#type' => 'select',
            '#title' => t('Phase Template'),
            '#default_value' => variable_get('lingotek_phase_template', ''),
            '#options' => lingotek_get_phase_templates(),
          );
        }
      }
  }
}

/*
 * help hook
 *
 * link to Help Documentation
 */
function lingotek_help($path, $arg) {
  switch ($path) {
    case 'admin/help#lingotek':
      return t('Please see our DevZone:') . ' ' . l(t('Drupal Integration'), 'http://lingotek.com/support/devzone/drupal-integration');
  }
}

/*
 * nodeapi hook
 */
function lingotek_nodeapi($node, $op, $teaser, $page) {
  if ($node->language == "") {
    $node->language = variable_get('lingotek_neutral_language', 'en');
  }
  switch ($op) {
    case 'view':
        $view_mode = '';
        if ($page) {
          $view_mode = 'full';
        }
        lingotek_node_view($node, $view_mode);
      break;
    case 'update':
      lingotek_node_update($node);
      break;
    case 'delete':
      lingotek_node_delete($node);
      break;
    case 'insert':
        lingotek_node_insert($node);
      break;
  }
}

/*
 * nodeapi update
 */
function lingotek_node_update($node) {
  global $_lingotek_client;

  $doc_id = lingotek_lingonode($node->nid, 'document_id');
  if ($doc_id == FALSE) {
    return;
  }

  $xml = "<?xml version=\"1.0\"?><contents><title><![CDATA[" . $node->title . "]]></title><body><![CDATA[" . $node->body . "]]></body></contents>";

  $_lingotek_client->request('updateContentDocument', array('documentId' => $doc_id, 'content' => $xml));
}

/*
 * nodeapi hook view operation (node_view hook, Drupal 7)
 */
function lingotek_node_view($node, $view_mode) {
  global $_lingotek_client, $_lingotek_locale;

  if ($node->tnid && $node->tnid != $node->nid && $view_mode == 'full') {
    if (($cache = cache_get('lingotek_' + $node->nid + '_link')) && !empty($cache->data) && time() < $cache->expire) {
      $link = $cache->data;
    }
    else {
      $doc_id = lingotek_lingonode($node->tnid, 'document_id');

      $output = $_lingotek_client->request('listTranslationTargets', array('documentId' => $doc_id));
      if ($output->results == "success") {
        $this_target;
        $phase_id;
        foreach ($output->translationTargets as $target) {
          if ($target->language == $_lingotek_locale[$node->language]) {
            $this_target = $target;
            break;
          }
        }
        $which_phase = 0;
        //Must be returned in order:
        foreach ($this_target->phases as $phase) {
          if ($phase->percentComplete < 100) {
            $phase_id = $phase->id;
            break;
          }
          $which_phase++;
        }

        //Should we download at this point automatically at 100%?:
        //TODO: This is delayed until a second refresh. Once to download, once to display changes...
        if ($which_phase == count($this_target->phases)) {
          if (!lingotek_lingonode($node->nid, "downloaded") ) {
            $source_node = node_load(array('nid' => $node->tnid));
            lingotek_download_document($source_node, $node, TRUE);
            lingotek_lingonode($node->nid, "downloaded", TRUE);
          }
        }
        else {
          //We only want to give this message until they reach 100%:
          $message .= t("The translation of this page is still being worked on.") . " ";
          $message .= lingotek_workbench_phase_link($doc_id, $phase_id, t("Help make it better."));
        }
      }

      $link = array
      (
        'which_phase' => $which_phase,
        'message' => $message,
      );
      cache_set('lingotek_' + $node->nid + '_link', $link, 'cache', time() + 900);
    }

    if ( (user_access('lingotek_translate') && $link['which_phase'] == 0) || (user_access('lingotek_review_translations') && $link['which_phase'] != 0) ) {
      drupal_set_message($link['message']);
    }
  }
}

/*
 * nodeapi hook delete operation (node_delete hook, Drupal 7)
 */
function lingotek_node_delete($node) {
  global $_lingotek_client, $_lingotek_locale;

  //Handle cleanup of target languages
  //Node is the source language, so no need to remove a target language.
  $tnid = lingotek_lingonode($node->nid, 'tnid');
  if ($tnid) {
    $doc_id = lingotek_lingonode($tnid, 'document_id');

    $output = $_lingotek_client->request('getDocument', array('documentId' => $doc_id));
    if ($output->results == "success") {
      foreach ($output->translationTargets as $target) {
        if ($target->language == $_lingotek_locale[$node->language]) {
          $_lingotek_client->request('removeTranslationTarget', array('translationTargetId' => $target->id));
        }
      }
    }

  }
}

/*
 * nodeapi hook insert operation (node_insert hook, Drupal 7)
 *
 * Handle saving the phaseTemplate from the form on a new node's creation.
 */
function lingotek_node_insert($node) {
  if (isset($node->phaseTemplate)) {
    lingotek_lingonode($node->nid, 'phaseTemplate', $node->phaseTemplate);
  }
}

/*
 * menu_link_alter hook
 *
 * Menu Overwriting functionality (Requires the Menu Translation in i18n to be
 * enabled and it's setting enabled within this module)
 *
 * Determines if lingotek_translated_menu_link_alter will be called on a link.
 */
function lingotek_menu_link_alter(&$item, $menu) {
  if ($item['external'] == "0" && $item["access_callback"] == "node_access") {
    $item['options']['alter'] = TRUE;
  }
}

/*
 * translated_menu_link_alter hook
 *
 * Menu Overwriting functionality (Requires the Menu Translation in i18n to be
 * enabled and it's setting enabled within this module)
 *
 * Alters the link so that Menus correctly point to target languages when the
 * user is it's language instead of pointing to the source language's node
 */
function lingotek_translated_menu_link_alter(&$item, $menu) {
  global $language;

  if ($item["menu_name"] != "navigation" && variable_get('lingotek_menu_overwrite', FALSE)) {

    $nid = str_replace(str_replace("%", "", $item['router_path']), "", $item['link_path']);
    $node = lingotek_get_node($language->prefix, $nid);
    if ($node && $node->title != "") {
      $item['href'] = str_replace("%", $node->nid, $item['router_path']);
      $item['link_title'] = $node->title;
    }
    $item["access"] = TRUE;
  }
}
