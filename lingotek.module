<?php
/**
 * @file
 * Module core functionality.
 */

/**
 * Identifies a content type which has Lingotek translation enabled.
 */
define('LINGOTEK_ENABLED', 5);

include_once('lingotek.session.inc');
include_once('lingotek.reference.inc');
include_once('lingotek.util.inc');
include_once('lingotek.api.inc');
include_once('lingotek.mt.inc');

/**
 * Implements hook_menu().
 */
function lingotek_menu() {
  $items = array();

  $items['admin/settings/lingotek'] = array(
    'title' => 'Lingotek',
    'access arguments' => array('administration'),
    'description' => 'Community Translation Settings',
    'file' => 'lingotek.admin.inc',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lingotek_admin_form'),
  );

  $items['node/%node/lingotek_pm'] = array(
    'title' => 'Lingotek',
    'access arguments' => array(1, 'pm'),
    'access callback' => 'lingotek_access',
    'file' => 'lingotek.page.inc',
    'page arguments' => array(1),
    'page callback' => 'lingotek_pm',
    'type' => MENU_LOCAL_TASK,
    'weight' => 3,
  );

  $items['lingotek/update'] = array(
    'access arguments' => array('pm'),
    'file' => 'lingotek.page.inc',
    'page callback' => 'lingotek_update',
    'type' => MENU_CALLBACK,
  );

  $items['lingotek/mt_all'] = array(
    'access arguments' => array('administration'),
    'file' => 'lingotek.pages.inc',
    'page callback' => 'lingotek_mt_all',
    'type' => MENU_CALLBACK,
  );

  $items['lingotek/segment'] = array(
    'access arguments' => array('mt'),
    'file' => 'lingotek.mt.inc',
    'page callback' => 'lingotek_mt_save_segment',
    'type' => MENU_CALLBACK,
  );

  $items['admin/settings/lingotek/dev'] = array(
    'title' => 'Lingotek Developer Tools',
    'access arguments' => array('dev'),
    'description' => 'Developer Tools',
    'file' => 'lingotek.dev.inc',
    'page callback' => 'lingotek_dev_page',
  );

  $items['admin/config/regional/field-data-cleanup'] = array(
    'title' => 'Lingotek Field Data Cleanup Utility',
    'description' => 'Updates language settings for existing field data.',
    'access arguments' => array('access lingotek utilities'),
    'file' => 'lingotek.admin.inc',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lingotek_form_field_language_utility'),
    'type' => MENU_NORMAL_ITEM,
  );

  $items['node/%node/lingotek_dev'] = array(
    'title' => 'Lingotek Developer Tools',
    'access arguments' => array('dev'),
    'description' => 'Developer Tools',
    'file' => 'lingotek.dev.inc',
    'page callback' => 'lingotek_dev_page',
    'page arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function lingotek_menu_alter(&$items) {
  // If the Entity Translation module is enabled alongside Lingotek,
  // allow nodes that haven't yet been associated with Lingotek to be
  // translated using Entity Translation's tools.
  if (module_exists('entity_translation')) {
    $translate_path = 'node/%node/translate';
    $lingotek_access_callback = 'lingotek_entity_translation_node_tab_access';
    if (isset($items[$translate_path])) {
      $items[$translate_path]['title'] = 'Translate (Entity Translation)';
      $items[$translate_path]['access callback'] = $lingotek_access_callback;
    }

    $menu_targets = array(
      'node/%node/translate/add/%entity_translation_language/%entity_translation_language',
      'node/%node/translate/delete/%entity_translation_language',
    );

    foreach ($menu_targets as $target) {
      if (isset($items[$target])) {
        $items[$target]['access callback'] = $lingotek_access_callback;
      }
    }

    $edit_target = 'node/%node/translate/edit/%entity_translation_language';
    if (isset($items[$edit_target])) {
      $items[$edit_target]['access callback'] = 'lingotek_entity_translation_edit_access';
      $items[$edit_target]['access arguments'][3] = $lingotek_access_callback;
    }
  }
}

/**
 * Entity Translation access callback when enabled with Lingotek module.
 *
 * @return bool
 *   TRUE if the user should be able to access the requested resource, FALSE otherwise.
 *
 * @see entity_translation_node_tab_access().
 */
function lingotek_entity_translation_node_tab_access() {
  $args = func_get_args();
  $node = array_shift($args);
  if ($node->language != LANGUAGE_NONE) {
    if (lingotek_supported_type($node->type) &&
      !lingotek_lingonode($node->nid, 'create_lingotek_document') &&
      !lingotek_lingonode($node->nid, 'document_id_' . $node->language)) {

      return TRUE;
    }
    elseif (entity_translation_node_supported_type($node->type)) {
      return entity_translation_tab_access('node');
    }
    elseif (entity_translation_node('node', $node)) {
      $function = array_shift($args);
      return call_user_func_array($function, $args);
    }
  }

  return FALSE;
}

/**
 * Entity Translation edit access callback when enabled with Lingotek module.
 *
 * @return bool
 *   TRUE if the user should be able to access the requested resource, FALSE otherwise.
 *
 * @see entity_translation_edit_access()
 */
function lingotek_entity_translation_edit_access($entity_type, $entity, $langcode) {
  $translations = entity_translation_get_handler($entity_type, $entity)->getTranslations();
  // If a translations for the given language does not exist we cannot edit it.
  if (!isset($translations->data[$langcode])) {
    return FALSE;
  }
  // Invoke the actual callback with its arguments.
  $args = func_get_args();
  return call_user_func_array($args[3], array_slice($args, 4));
}

/**
 * Implements hook_permission().
 */
function lingotek_permission() {
  return array(
    'access lingotek utilities' => array(
      'title' => t('Access Lingotek Utilities'),
      'description' => t('Access admin-only utility pages.')
    ),
    'access per-item lingotek project selection' => array(
      'title' => t('Per-item Project Selection'),
      'description' => t('Access the Lingotek Project selector on content creation forms.')
    ),
    'access per-item lingotek vault selection' => array(
      'title' => t('Per-item Vault Selection'),
      'description' => t('Access the Lingotek TM Vault selector on content creation forms.')
    ),
    'administration' => array('title' => 'Administration Menu', 'description' => t('Access the administrative page for the module.')),
    'pm' => array('title' => 'Project Management', 'description' => t('Access the Lingotek tab on content types (Must also have permission to edit the content type in question).')),
    'translation' => array('title' => 'Translate', 'description' => t('Allow access to the workbench for translation (first) phases')),
    'review' => array('title' => 'Review', 'description' => t('Allow access to the workbench for review (following) phases.')),
    'phase_template' => array('title' => 'Phase Template (Workflow)', 'description' => t('Allow node-level setting of the phase template on node creation.  Can only be set once per node.')),
    'use_source' => array('title' => 'Paste Source', 'description' => t('Allow node-level setting of showing the source when no translation is available yet')),
    'sync_method' => array('title' => 'Synchronization Method', 'description' => t('Allow node-level setting of setting the synchronization method')),
    'url_alias_translation' => array('title' => 'URL Alias Translation', 'description' => t('Allow node-level setting of setting the URL alias translation')),
    'mt' => array('title' => 'Machine Translation', 'description' => t('Allow node-level setting of machine translation')),
    'dev' => array('title' => 'Developer', 'description' => t('Access useful debugging features')),
  );
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 *
 * @param array $form
 *   A FAPI form array for the form being altered.
 * @param array $form_state
 *   A FAPI form state array for the form being altered.
 * @param string $form_id
 *   The ID of the form being altered.
 */
function lingotek_form_node_form_alter(&$form, $form_state, $form_id) {
  global $_lingotek_locale;

  if (!lingotek_supported_type($form['#node']->type)) {
    return;
  }

  drupal_add_css(drupal_get_path('module', 'lingotek') . '/style/form.css');

  $options = array();
  $options[TRUE] = t('Enabled');
  $options[FALSE] = t('Disabled');

  // Vertical Tab.
  $form['lingotek'] = array(
    '#title' => t('Lingotek Translation Settings'),
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#group' => 'additional_settings',
    '#attributes' => array('id' => array('lingotek_fieldset')),
    '#attached' => array(
      'js' => array(drupal_get_path('module', 'lingotek') . '/js/lingotek.form.js'),
    ),
  );

  $form['lingotek']['note'] = array(
    '#type' => 'item',
    '#title' => t('Lingotek Translation Settings'),
    '#description' => t('Please select a language for Lingotek to use as the source language.  The source language cannot be language neutral.'),
  );

  $form['lingotek']['content'] = array(
    '#type' => 'container',
  );

  $form['lingotek']['content']['note'] = array(
    '#type' => 'item',
    '#title' => t('Lingotek Translation Settings'),
    '#description' => t("The Lingotek Collaborative Translation module was developed by Lingotek to aid administrators of Drupal-created websites in getting their web content translated. The module integrates Lingotek's Collaborative Translation Platform directly into Drupal, so that your users can leverage the power of Lingotek's translation tools without ever having to leave the comfort of their Drupal environment."),
  );

  $node = lingotek_empty_node();
  $document_id = FALSE;
  if (isset($form['nid']['#value'])) {
    $nid = $form['nid']['#value'];
    $node = node_load($nid);
    $document_id = lingotek_lingonode($nid, 'document_id_' . $node->language);
  }

  // Only show these options if the Lingotek document hasn't yet been created.
  if (!$document_id && class_exists('LingotekApi')) {
    if ($node->nid > 0) {
      lingotek_check_entity_translations($node);
    }

    // Available projects.
    if ($projects = LingotekApi::instance()->listProjects()) {
      $form['lingotek']['content']['lingotek_project_id'] = array(
        '#type' => 'select',
        '#title' => 'Project ID',
        '#description' => t('Select the translation project with which this item should be associated.'),
        '#default_value' => variable_get('lingotek_project', ''),
        '#options' => $projects,
        '#access' => user_access('access per-item lingotek project selection'),
      );
    }

    // Translation Memory (TM) Vault.
    if ($vaults = LingotekApi::instance()->listVaults()) {
      $form['lingotek']['content']['lingotek_vault_id'] = array(
        '#type' => 'select',
        '#title' => t('TM Vault'),
        '#description' => t('Choose the TM vault to associate with this content item.'),
        '#default_value' => variable_get('lingotek_vault', ''),
        '#options' => $vaults,
        '#access' => user_access('access per-item lingotek vault selection'),
      );
    }
  }

  // Sync Setting.
  $form['lingotek']['content']['syncMethod'] = array(
    '#type' => 'radios',
    '#title' => t('Synchronization Method'),
    '#default_value' => lingotek_variable_get(lingotek_lingonode($node->nid, 'sync_method'), 'lingotek_sync', 0),
    '#options' => lingotek_get_sync_methods(),
    '#access' => user_access('sync_method'),
    '#description' => t("How do you want content on this site to be kept in sync with Lingotek?  Do you want translations to be current and the latest (Always), or only downloaded from Lingotek when done (100%)?  \"Never\" requires you to manually synchronize on the page's Lingotek tab by calling update."),
  );

  // Paste Source Setting.
  $form['lingotek']['content']['useSource'] = array(
    '#type' => 'select',
    '#title' => t('Include source text in synchronization.'),
    '#default_value' => lingotek_variable_get(lingotek_lingonode($node->nid, 'use_source'), 'lingotek_use_source', TRUE),
    '#options' => $options,
    '#access' => user_access('use_source'),
    '#description' => t("This determines if the target languages will fill untranslated text with the source language or simply leave untranslated text out of the document."),
  );

  // Create Lingotek Document?
  if (empty($form['nid']['#value']) || (!empty($form['nid']['#value']) && lingotek_lingonode($form['nid']['#value'], 'document_id_' . $form['#node']->language) === FALSE)) {
    $form['lingotek']['content']['create_lingotek_document'] = array(
      '#type' => 'select',
      '#title' => t('Push Node to Lingotek'),
      '#default_value' => lingotek_variable_get(lingotek_lingonode($node->nid, 'create_lingotek_document'), 'lingotek_create_documents_by_default', 0),
      '#options' => array(
        1 => t('Yes'),
        0 => t('No')
      ),
      '#description' => t("This determines if content should be pushed to the Lingotek Platform. Changing the setting to Yes is irreversible."),
    );
  }

  // Machine translation settings.
  if (user_access('mt')) {
    $available_engines = lingotek_get_machine_translation_engines();
    $enabled_engines = variable_get('lingotek_available_mt_options', array_keys($available_engines));
    $engines = array();
    foreach ($enabled_engines as $engine) {
      $engines[$engine] = $available_engines[$engine];
    }

    $form['lingotek']['content']['mtEngine'] = array(
      '#type' => 'select',
      '#title' => t('Machine Translation Engine'),
      '#default_value' => lingotek_variable_get(lingotek_lingonode($node->nid, 'mt_engine'), 'lingotek_mt_engine', FALSE), //Only run MT when specified
      '#options' => $engines,
      '#description' => t("Choose an engine to automatically translate the content with. Warning: This will automatically synchronize the content as a manual update would from the Lingotek tab for the page."),
    );

    $languages = array();
    $checked = array();
    foreach (language_list() as $language) {
      if ($language->enabled && isset($_lingotek_locale[$language->language])) {
        $languages[$language->language] = $language->native . " (" . $language->name . ")";
        array_push($checked, $language->language);
      }
    }
    $saved = lingotek_lingonode($node->nid, 'mt_targets');
    if ($saved !== FALSE) {
      $checked = explode(",", $saved);
    }

    $form['lingotek']['content']['mtTargets'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Apply Machine Translation to the following languages'),
      '#options' => $languages,
      '#default_value' => $checked,
      '#description' => t("Choose which languages should be machine translated with the above engine."),
    );
  }

  // URL Alias Translation.
  if (user_access('url_alias_translation')) {
    $form['lingotek']['content']['urlAliasTranslation'] = array
    (
      '#type' => 'radios',
      '#title' => t('URL Alias Translation'),
      '#default_value' => lingotek_variable_get(lingotek_lingonode($node->nid, 'url_alias_translation'), 'lingotek_url_alias_translation', 0),
      '#options' => lingotek_get_url_alias_translations(),
      '#description' => t("Choose how you would like to translate the URL alias. The last option requires that you install both the Title and Pathauto modules, and define a path pattern, and check \"Enable Lingotek Translation\" for the Title field."),
    );
  }

  $form['lingotek']['developer'] = array(
    '#type' => 'fieldset',
    '#title' => t('Developer Settings (Advanced)'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#group' => 'developer_settings',
    '#access' => user_access('dev'),
  );
  if ($document_id === False) {
    $document_id = '';
  }
  $form['lingotek']['developer']['document_id'] = array(
    '#type' => 'textfield',
    '#title' => t('Document Id'),
    '#description' => t("Read/Overwrite the document ID associated with the document.  This can break the translation process but can also be used to help figure out if something is wrong."),
    '#default_value' => $document_id,
  );

  $values = t('None');
  if (isset($nid)) {
    $values = json_encode(lingotek_lingonode($nid));
  }
  $form['lingotek']['developer']['current_lingonode'] = array(
    '#type' => 'item',
    '#title' => t('Node Variables'),
    '#description' => $values,
  );

}

/**
 * hook_node_view
 */
function lingotek_node_view($node, $view_mode) {
  global $language, $first_load, $user;

  if ($view_mode == 'full' && lingotek_supported_type($node->type) && lingotek_supported_language($node->language)) {
    drupal_add_css(drupal_get_path('module', 'lingotek') . '/style/base.css');
    lingotek_trace('lingotek_node_view');
    lingotek_node_sync($node);

    if ($language->language != $node->language) {
      $link = (!user_is_anonymous()) ? lingotek_get_workbench_url($node, $language->language, t('Help make it better.')) : '';
      if ($link != "") {
        $message = t('The translation of %title is still being worked on.', array('%title' => $node->title)) . " ";
        $message .= $link . "&nbsp;";
        if (lingotek_access($node, 'pm')) {
          $message .= '<span style="font-size: 80%">[' . l(t('progress'), 'node/' . $node->nid . '/lingotek_pm', array('html' => true)) . ']</span>';
        }
        drupal_set_message($message, 'warning', FALSE);
      }
    }
  }
}

function lingotek_node_presave($node) {
  // Make sure the title isn't overwritten with the translation when using the title module.
  if (module_exists('title') && array_key_exists('title_field', $node)) {
    $node->title = $node->title_field[$node->language][0]['value'];
  }
}

/**
 * Implements hook_node_insert().
 */
function lingotek_node_insert($node) {
  lingotek_node_update($node);
}

/**
 * Implements hook_node_update().
 */
function lingotek_node_update($node) {
  $send_lingotek_document = (!empty($node->create_lingotek_document) || lingotek_lingonode($node->nid, 'document_id_' . $node->language));

  // If the user explicitly requested that this item not be pushed to Lingotek, set the Lingonode property so that the
  // edit form default can be set appropriately on subsequent edits.
  if (isset($node->create_lingotek_document)) {
    lingotek_lingonode($node->nid, 'create_lingotek_document', $node->create_lingotek_document);
  }

  if (!lingotek_supported_type($node->type) || !lingotek_supported_language($node->language) || !$send_lingotek_document) {
    return;
  }

  // Overwrite document ID.
  if (user_access('dev') && isset($node->document_id) && is_numeric($node->document_id)) {
    lingotek_lingonode($node->nid, 'document_id_' . $node->language, $node->document_id);
  }
  if (isset($node->mtEngine)) {
    lingotek_lingonode($node->nid, 'mt_engine', $node->mtEngine);
  }
  if (user_access('url_alias_translation') && isset($node->urlAliasTranslation)) {
    lingotek_lingonode($node->nid, 'url_alias_translation', $node->urlAliasTranslation);
  }

  if (isset($node->mtTargets)) {
    $node->mtTargets = array_filter($node->mtTargets, "lingotek_unselected");
    lingotek_lingonode($node->nid, 'mt_targets', implode(",", $node->mtTargets));
  }

  // Items that are only accessible on node add or edit forms for nodes not yet sent to Lingotek.
  if (lingotek_lingonode($node->nid, 'document_id_' . $node->language) === FALSE) {
    lingotek_trace('lingotek_node_update FIRST RUN ONLY', array("nid" => $node->nid, "language" => $node->language));

    $project_id = variable_get('lingotek_project', 0);
    if (user_access('access per-item lingotek project selection') && !empty($node->lingotek_project_id)) {
      $project_id = $node->lingotek_project_id;
    }
    lingotek_lingonode($node->nid, 'project_id', $project_id);

    $vault_id = variable_get('lingotek_vault', '');
    if (user_access('access per-item lingotek vault selection') && !empty($node->lingotek_vault_id)) {
      $vault_id = $node->lingotek_vault_id;
    }
    lingotek_lingonode($node->nid, 'vault_id', $vault_id);

    // Removes local translations if this node has been previously translated using Entity Translation.
    lingotek_remove_local_translations($node);

    if (LingotekApi::instance()->addContentDocument($node)) {
      drupal_set_message(t('<em>@node_title</em> sent to Lingotek successfully.', array('@node_title' => $node->title)));
    }
    else {
      drupal_set_message(t('Unable to send <em>@node_title</em> to Lingotek.', array('@node_title' => $node->title)), 'error');
    }

    // Run machine translation for the first time.
    if (user_access('mt')) {
      if (isset($node->mtEngine) && $node->mtEngine) {
        lingotek_mt($node, $node->mtTargets, $node->mtEngine);
      }
    }
    else {
      $checked = array();
      foreach (language_list() as $language) {
        if ($language->enabled) {
          array_push($checked, $language->language);
        }
      }
      lingotek_mt($node, $checked, variable_get('lingotek_mt_engine', FALSE));
    }
  }
  else {
    // Keep source document up to date.
    LingotekApi::instance()->updateContentDocument($node);

    // Run machine translation.
    if (user_access('mt') && isset($node->mtEngine) && $node->mtEngine) {
      lingotek_mt($node, $node->mtTargets, $node->mtEngine);
    }
  }

  if (user_access('sync_method') && isset($node->syncMethod)) {
    lingotek_lingonode($node->nid, 'sync_method', $node->syncMethod);
  }
  if (user_access('use_source') && isset($node->useSource)) {
    lingotek_lingonode($node->nid, 'use_source', $node->useSource);
  }

  // Add any missing languages and their phase templates.
  lingotek_add_missing_targets($node);
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Enable Lingotek translation on a node type
 */
function lingotek_form_node_type_form_alter(&$form, &$form_state) {
  $type = $form['#node_type']->type;
  $lingotek_option_label = (module_exists('entity_translation')) ?
    t('Enabled, with Lingotek translation or field translation.'): t('Enabled, with Lingotek translation');
  $form['workflow']['language_content_type']['#options'][LINGOTEK_ENABLED] = $lingotek_option_label;
  $form['workflow']['language_content_type']['#description'] .= ' ' . t('If Lingotek translation is enabled, then it will be possible to use Lingotek\'s collaborative workbench to translate content.');
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Enable Lingotek translation on a field type
 */
function lingotek_form_field_ui_field_edit_form_alter(&$form, &$form_state) {
  if (!lingotek_supported_field_type($form['#field']['type'])) {
    return $form;
  }
  $default = 0;
  if (array_key_exists('lingotek_translatable',  $form['#field'])) {
    $default = $form['#field']['lingotek_translatable'];
  }

  $form['field']['lingotek_translatable'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable Lingotek Translation'),
    '#description' => t('This allows fields to be translatable using the Lingotek Collaborative Translations Platform.'),
    '#default_value' => $default,
  );
  array_push($form['#submit'], 'lingotek_update_field');
  return $form;
}

function lingotek_update_field($form, $form_state) {
  $field = $form['#field']['field_name'];
  db_update('field_config')->fields(array('translatable' => $form['field']['lingotek_translatable']['#value']))->condition('field_name', $field)->execute();
}

/*
 * hook_preprocess_page
 * flush the queue for machine translation on every page load
 */
function lingotek_preprocess_page(&$page, $hook) {
  //Process MT queue once per page load
  lingotek_dequeue();
}

/*
 * hook_help
 */
function lingotek_help($path, $arg) {
  switch ($path) {
    case 'admin/help#lingotek':
      return t('Please see our DevZone:') . ' ' . l(t('Drupal Integration'), 'http://lingotek.com/support/devzone/drupal-integration');
  }
}

/**
 * Batch API processor for field data language updates.
 */
function lingotek_handle_batch_field_language_update($nid, &$context) {
  $process_node = node_load($nid);

  if ($process_node->nid) {
    lingotek_update_language_field_data($process_node->nid);
    $context['message'] = t('Updating field data for node: @node_title', array('@node_title' => $process_node->title));
  }

  $context['finished'] = 1;
}

/**
 * Ensures correct language-specific field data for the specified item.
 *
 * @param int $nid
 *   The node ID of the item to be updated.
 *
 * @return bool
 *   TRUE if the specified node's field data was updated. FALSE if no changes were made.
 */
function lingotek_update_language_field_data($nid) {
  $edited = FALSE;

  $node = node_load($nid, NULL, TRUE);
  if ($node->nid) {
    if ($node->language != 'und') {
      $translatable_fields = lingotek_translatable_node_fields();
      foreach ($translatable_fields as $field_name) {
        if (!empty($node->{$field_name}['und']) && empty($node->{$field_name}[$node->language])) {
          $node->{$field_name}[$node->language] = $node->{$field_name}['und'];
          $edited = TRUE;
        }
      }
    }

    if ($edited) {
      node_save($node);
    }
  }
  else {
    watchdog('lingotek', 'Attempted to update field data for a non-existent node: @node_id',
      array('@node_id' => $node_id), WATCHDOG_ERROR);
  }

  return $edited;
}

/**
 * Gets a list of fields with translation enabled.
 *
 * @return array
 *   An array of the machine names for translatable fields in the system.
 */
function lingotek_translatable_node_fields() {
  $fields = field_info_fields();
  $translatable_fields = array();
  foreach ($fields as $field_id => $field) {
    foreach ($field['bundles'] as $type => $instance) {
      if (field_is_translatable($type, $field)) {
        $translatable_fields[] = $field['field_name'];
      }
    }
  }

  return $translatable_fields;
}

/**
 * "Finished" callback for language update batch operations.
 */
function lingotek_field_language_update_finished($success, $results, $operations) {
  drupal_set_message('Updated field data for nodes.') ;
}

/**
 * Processing callback for the advanced parsing update batch operation.
 */
function lingotek_advanced_parsing_update_node($nid, &$context) {
  $process_node = node_load($nid);

  if (!empty($process_node->nid)) {
    $context['message'] = t('Sending advanced parsing data to Lingotek for node @node_id: @node_title',
      array('@node_id' => $process_node->nid, '@node_title' => $process_node->title));
    if (LingotekApi::instance()->updateContentDocument($process_node)) {
      $context['results'][] = t('Updated node: @id', array('@id' => $process_node->nid));
    }
    else {
      watchdog('lingotek', 'Unable to send advanced XML version of node to Lingotek: @node_id',
        array('@node_id' => $process_node->nid), WATCHDOG_ERROR);
    }
  }
}

/**
 * "Finished" callback for the XML update batch operation.
 */
function lingotek_advanced_parsing_update_finished($success, $results, $operations) {
  if ($success) {
    drupal_set_message(t('Advanced parsing updates complete.'));
  }
  else {
    drupal_set_message(t('There were errors updating one or more existing Lingotek documents.'), 'error');
  }
}

/**
 * Installs the default advanced XML configuration that ships with the module.
 */
function lingotek_install_default_advanced_xml() {
  $filepath_stub = DRUPAL_ROOT . '/' . drupal_get_path('module', 'lingotek') . '/fprm/';
  $config_file_primary = $filepath_stub . 'okf_xmlstream@drupal_filter.fprm';
  $config_file_secondary = $filepath_stub . 'okf_html@drupal_subfilter.fprm';

  if ($config = file_get_contents($config_file_primary)) {
    variable_set('lingotek_advanced_xml_config1', $config);
  }
  else {
    watchdog('lingotek', 'Unable to install default primary advanced XML configuration from: @config_file',
      array('@config_file' => $config_file_primary), WATCHDOG_ERROR);
  }

  if ($config2 = file_get_contents($config_file_secondary)) {
    variable_set('lingotek_advanced_xml_config2', $config2);
  }
  else {
    watchdog('lingotek', 'Unable to install default secondary advanced XML configuration from: @config_file',
      array('@config_file' => $config_file_secondary), WATCHDOG_ERROR);
  }

}

/**
 * Checks for existing local entity_translations and sets JS settings appropriately.
 */
function lingotek_check_entity_translations($node) {
  if (module_exists('entity_translation')) {
    if ($handler = entity_translation_get_handler('node', $node)) {

      $translations = $handler->getTranslations();
      if (isset($translations->data[$translations->original])) {
        unset($translations->data[$translations->original]);
      }

      $settings = array(
        'lingotek_no_document' => TRUE,
        'lingotek_has_entity_translations' => count($translations->data),
      );
      drupal_add_js($settings, 'setting');
    }
    else {
      watchdog('lingotek', 'Unable to load entity translation handler', NULL, WATCHDOG_ERROR);
    }
  }
}

/**
 * Removes any local translations that may have been added via Entity Translation.
 *
 * @param object $node
 *   The Drupal node for which local translations should be removed.
 *
 * @return mixed
 *   The number of removed translations if action was taken, FALSE on error.
 */
function lingotek_remove_local_translations($node) {
  // Sanity check that this item has not already been sent to Lingotek.
  if (module_exists('entity_translation')) {
    if (lingotek_lingonode($node->nid, 'document_id_' . $node->language) !== FALSE) {
      watchdog('lingotek', 'Attempted to remove local translations for a node already sent to Lingotek: @node_id',
        array('@node_id' => $node->nid), WATCHDOG_ERROR);
      return FALSE;
    }
    else {
      if ($handler = entity_translation_get_handler('node', $node)) {

        $translations = $handler->getTranslations();
        $languages = language_list();
        foreach ($translations->data as $language_code => $data) {
          if ($language_code != $translations->original) {
            $handler->removeTranslation($language_code);
            field_attach_update('node', $node);
            drupal_set_message(t('Removed local translation for @language.', array('@language' => $languages[$language_code]->name)));
          }
        }
      }
      else {
        watchdog('lingotek', 'Unable to load entity translation handler', NULL, WATCHDOG_ERROR);
      }
    }
  }
}
